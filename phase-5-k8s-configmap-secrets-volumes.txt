Kubernetes ConfigMaps + Secrets + Volume Mounts
This phase will introduce managing application configuration and sensitive data in Kubernetes along with persistent storage.

🔸 Goals:
    1. Use ConfigMap to inject application configs (e.g., Spring Boot application.properties).
    2. Use Secrets to securely pass credentials (e.g., DB password).
    3. Mount a Persistent Volume (PV) and Persistent Volume Claim (PVC).
    4. Reference these in your deployment YAML.
    5. Re-deploy the app using Jenkins + Minikube
============
PHASE-5: K8s ConfigMap + Secrets + Volume Mounts Recap
📁 Project Structure Overview
    springboot-docker-jenkins-k8s/
    │
    ├── src/
    │   └── main/resources/
    │       └── (no default application.properties if using external config)
    │
    ├── Dockerfile
    ├── Jenkinsfile
    └── k8s/
        ├── configmap.yaml
        ├── secret.yaml
        ├── deployment.yaml
        └── service.yaml

1️⃣ Create ConfigMap

# k8s/configmap.yaml
    apiVersion: v1
    kind: ConfigMap
    metadata:
      name: app-config
    data:
      application.properties: |
        message.value=Message from Kubernetes ConfigMap
✅ Apply:
      D:\SPTechZone\springboot-docker-jenkins-k8s> kubectl apply -f k8s/configmap.yaml

2️⃣ Create Secret
# k8s/secret.yaml
    apiVersion: v1
    kind: Secret
    metadata:
      name: app-secret
    type: Opaque
    stringData:
      app.password: superSecret123
✅ Apply:
    D:\SPTechZone\springboot-docker-jenkins-k8s> kubectl apply -f k8s/secret.yaml

3️⃣ K8s Deployment with Volume Mount for ConfigMap + Secrets
# k8s/deployment.yaml
    apiVersion: apps/v1
    kind: Deployment
    metadata:
      name: springboot-app
    spec:
      replicas: 1
      selector:
        matchLabels:
          app: springboot-app
      template:
        metadata:
          labels:
            app: springboot-app
        spec:
          containers:
            - name: springboot-container
              image: dockerjenkinsk8s:latest
              imagePullPolicy: Never
              ports:
                - containerPort: 8080
              env:
                - name: APP_PASSWORD
                  valueFrom:
                    secretKeyRef:
                      name: app-secret
                      key: app.password
              volumeMounts:
                - name: config-volume
                  mountPath: /config
                  readOnly: true
          volumes:
            - name: config-volume
              configMap:
                name: app-config
🔥 Mount path /config is where application.properties will reside inside the container.

✅ Apply:
    D:\SPTechZone\springboot-docker-jenkins-k8s> kubectl apply -f k8s/deployment.yaml

4️⃣ K8s Service
# k8s/service.yaml
    apiVersion: v1
    kind: Service
    metadata:
      name: springboot-service
    spec:
      type: NodePort
      selector:
        app: springboot-app
      ports:
        - protocol: TCP
          port: 8080
          targetPort: 8080
          nodePort: 30080

✅ Apply:
    D:\SPTechZone\springboot-docker-jenkins-k8s> kubectl apply -f k8s/service.yaml

🧪 Java Config Setup
📌 application startup flag:
Use additional config location via Docker:

#dockerfile
     ENTRYPOINT ["java", "-Dspring.config.additional-location=file:/config/", "-jar", "/app.jar"]
This lets Spring Boot read /config/application.properties inside container, mounted from ConfigMap.

🧪 Read Property in Controller
@Value("${message.value:Default fallback message}")
private String message;

@GetMapping("/message")
public ResponseEntity<String> message() {
    return ResponseEntity.ok(message);
}

🧪 Read Secret from Environment
@GetMapping("/secret")
public ResponseEntity<String> getSecret() {
    String password = System.getenv("APP_PASSWORD");
    return ResponseEntity.ok("Password from secret: " + password);
}

🧹 Cleanup & Restart Flow (Safe Reset)
D:\SPTechZone\springboot-docker-jenkins-k8s> kubectl delete -f k8s/service.yaml
D:\SPTechZone\springboot-docker-jenkins-k8s> kubectl delete -f k8s/deployment.yaml
D:\SPTechZone\springboot-docker-jenkins-k8s> kubectl delete -f k8s/configmap.yaml
D:\SPTechZone\springboot-docker-jenkins-k8s> kubectl delete -f k8s/secret.yaml

Or
D:\SPTechZone\springboot-docker-jenkins-k8s>kubectl delete -f k8s/

Then rebuild:
D:\SPTechZone\springboot-docker-jenkins-k8s> mvn clean package ( if not using jenkin build then for any latest application level changes)
D:\SPTechZone\springboot-docker-jenkins-k8s> & minikube -p minikube docker-env | Invoke-Expression
D:\SPTechZone\springboot-docker-jenkins-k8s> docker build --no-cache -t dockerjenkinsk8s:latest .
D:\SPTechZone\springboot-docker-jenkins-k8s> kubectl apply -f k8s/configmap.yaml
D:\SPTechZone\springboot-docker-jenkins-k8s> kubectl apply -f k8s/secret.yaml
D:\SPTechZone\springboot-docker-jenkins-k8s> kubectl apply -f k8s/deployment.yaml
D:\SPTechZone\springboot-docker-jenkins-k8s> kubectl apply -f k8s/service.yaml

Access via:
  D:\SPTechZone\springboot-docker-jenkins-k8s> minikube service springboot-service --url
 http://127.0.0.1:52814


✅ Summary of Key Concepts
Feature	Purpose	Usage Location
ConfigMap	Inject config files	/config/application.properties
Secret	Secure credentials via ENV	APP_PASSWORD
Volume Mount - Mount file into container	/config/
Spring Boot	External config loader	spring.config.additional-location
Jenkins	Image + Jar Build (already working)	Jenkinsfile