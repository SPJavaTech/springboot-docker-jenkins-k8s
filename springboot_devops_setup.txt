# ‚úÖ Full Spring Boot + Maven + Docker + Jenkins + Kubernetes (Minikube) on Windows

This guide walks you through setting up everything locally:
- Simple Spring Boot API
- Build with Maven
- Dockerize it
- Automate with Jenkins
- Deploy on Minikube (Kubernetes)

---

## üõ†Ô∏è 1. Install & Verify Prerequisites (on Windows)

### üîπ 1.1 Install Java 17
- Download: https://adoptium.net/
- Verify:
```bash
java -version
```

### üîπ 1.2 Install Maven
- Download: https://maven.apache.org/download.cgi
- Add to `PATH`
- Verify:
```bash
mvn -version
```

### üîπ 1.3 Install Docker Desktop
- Download: https://www.docker.com/products/docker-desktop/
- Enable **WSL2 integration** and **Kubernetes** during setup.
- Verify:
```bash
docker --version
docker info
```

### üîπ 1.4 Install Jenkins (with Docker)
docker run -d -p 8081:8080 -p 50000:50000 -v jenkins_home:/var/jenkins_home -v //var/run/docker.sock:/var/run/docker.sock --name jenkins jenkins/jenkins:lts

- Visit `http://localhost:8081`
- Unlock with the initial password (see logs):
```bash
docker logs jenkins | more
```

### üîπ 1.5 Install Minikube
- Download installer: https://minikube.sigs.k8s.io/docs/start/
- Enable Docker driver:
```bash
minikube config set driver docker
```
- Start cluster:
```bash
minikube start
```
- Verify:
```bash
kubectl get nodes
```

‚úÖ At this point: Jenkins is up, Minikube is running, and Docker is ready.

---

## üß± 2. Spring Boot Project (Hello API)

### üîπ `DemoApplication.java`
```java
@RestController
public class DemoApplication {
    public static void main(String[] args) {
        SpringApplication.run(DemoApplication.class, args);
    }

    @GetMapping("/hello")
    public String hello() {
        return "Hello from Spring Boot!";
    }
}
```

### üîπ `pom.xml`
Make sure it has the `spring-boot-maven-plugin`:
```xml
<build>
  <plugins>
    <plugin>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-maven-plugin</artifactId>
    </plugin>
  </plugins>
</build>
```

Build:
```bash
mvn clean package
```

---

## üê≥ 3. Dockerfile
FROM eclipse-temurin:21-jdk-alpine
COPY target/devops-1.0.1.jar app.jar
ENTRYPOINT ["java", "-jar", "app.jar"]

Build & run locally:

> docker build -t docker-jenkin-k8s .
> docker run -p 8080:8080 docker-jenkin-k8s
Visit `http://localhost:8080/hello`

---

## ü§ñ 4. Jenkinsfile (CI Pipeline)
```groovy
pipeline {
    agent any
    stages {
        stage('Build') {
            steps {
                sh 'mvn clean package'
            }
        }
        stage('Docker Build') {
            steps {
                sh 'docker build -t springboot-demo .'
            }
        }
    }
}
```

- Create a **Pipeline** job in Jenkins
- Paste the Jenkinsfile from Git repo or directly

---

## ‚ò∏Ô∏è 5. Kubernetes YAML (Minikube)

### üîπ `deployment.yaml`
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: springboot-deployment
spec:
  replicas: 1
  selector:
    matchLabels:
      app: springboot
  template:
    metadata:
      labels:
        app: springboot
    spec:
      containers:
        - name: springboot
          image: springboot-demo
          imagePullPolicy: IfNotPresent
          ports:
            - containerPort: 8080
```

### üîπ `service.yaml`
```yaml
apiVersion: v1
kind: Service
metadata:
  name: springboot-service
spec:
  type: NodePort
  selector:
    app: springboot
  ports:
    - protocol: TCP
      port: 80
      targetPort: 8080
      nodePort: 30080
```

---

## üöÄ 6. Deploy to Kubernetes (Minikube)
```bash
kubectl apply -f deployment.yaml
kubectl apply -f service.yaml
```
Access your app:
```bash
minikube service springboot-service --url
```

---

## ‚úÖ Summary

| Step         | Tool          | Purpose                            |
|--------------|---------------|------------------------------------|
| 1            | Java, Maven   | Spring Boot build system           |
| 2            | Docker        | Containerize your app              |
| 3            | Jenkins       | Automate build and image creation  |
| 4            | Minikube      | Local Kubernetes cluster           |
| 5            | kubectl       | Deploy YAML files to cluster       |

You now have an end-to-end working setup locally. Once you‚Äôre comfortable, we can add CI/CD and move to AWS EKS.

Let me know if you want this as a GitHub repo or ZIP file version to try out!
Git Branch Naming Convention for DevOps Learning
Branch Name	Purpose
phase-1-initial-setup	Spring Boot app + Maven build only
phase-2-dockerization	Add Dockerfile + run app in a container
phase-3-jenkins-pipeline	Jenkins setup + CI for Maven & Docker image
phase-4-k8s-basic-deployment	Kubernetes Deployment + Service YAML + Minikube deploy
phase-5-k8s-autoscaling	Horizontal Pod Autoscaler (HPA) added
phase-6-k8s-config-secrets	Externalize config via ConfigMap + Secret
phase-7-helm-charts	Helm chart setup for reusable Kubernetes deployments
phase-8-jenkins-cicd-k8s	Jenkins CI/CD: Full pipeline from code ‚Üí Docker ‚Üí K8s
phase-9-docker-jenkins-advanced	Multi-stage Docker + Jenkins shared libs & credentials
phase-10-cloud-migration	Optional: Migrate setup to EKS/AKS + Ingress + GitOps
Microservices Phase Plan (after Phase 5)
Phase	Branch Name	Focus
Phase 6 (A)	phase-6a-split-into-microservices	Convert monolith into 2 Spring Boot services (e.g., Employee + Department)
Phase 6 (B)	phase-6b-dockerize-microservices	Dockerize both services, run with Docker Compose
Phase 7 (Alt)	phase-7-k8s-microservices	Deploy both services to Kubernetes with communication via service names
Phase 8 (Alt)	phase-8-api-gateway-and-ingress	Add API gateway (Spring Cloud Gateway or Ingress) for routing and scaling